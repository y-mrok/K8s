# Kubernetes の目的
アプリケーションをコンテナの形で自動ホストし、必要な数のアプリケーションのインスタンスを簡単にデプロイし、アプリケーション内の異なるサービス間の通信を簡単に実現できるようにすること。

# Kubernetes のクラスタ
コンテナ形式でアプリケーションをホストする、オンプレミスまたはクラウド上の物理または仮想のノードセットで構成されている
## ワーカーノード
デプロしたコンテナを動作させるノード
- kubelet
- kube-proxy
- コンテナランタイムエンジン
## マスターノード（コントロールプレーン）
Kubernetes クラスターを管理するノード　＝　どのワーカーノード上でどのコンテナをデプロイするか管理するなどノードとコンテナを監視する
- ETCD クラスタ
- Kube Controller Manager
- kube-apiserver
- kube-scheduler
## etcd （ ETCD CLUSTER ）
- キーバリュー形式で情報を格納するデータベース
- ワーカーノード上にデプロイしたコンテナの情報などが含まれる
## kube-scheduler
- コンテナの情報に基づいてコンテナを配置するための適切なワーカーノードを特定する
## Controller-Manager
- Controller-Manager
- Node-controller
- Replication-Controller
## kube-apiserver
- クラスター内のすべてのオペレーションをオーケストレーションする役割を担っている
- 各種コントローラーがクラスタの状態を監視して必要に応じて変更したり、ワーカーノードがサーバーと通信したりするのに使用される
- 定期的に kubelet からステータスレポートを取得し、ワーカーノードやノード上のコンテナの状態を監視する
## コンテナランタイムエンジン
- コンテナを動かすためのソフトウェア（ Docker 等）
- コンテナランタイムエンジンは、マスターノードやワーカーノード等クラスタ内のすべてのノードにインストールする
## kubelet
- ワーカーノードで動作するエージェント
- kube-apiserver からの指示でワーカーノード上のコンテナをデプロイしたり破棄したりする
## kube-proxy サービス
ワーカーノード間の通信を受け持つ

# ETCD
## ETCD とは
シンプルで安全、かつ高速な分散型の信頼性の高いキーバリューストア
## キーバリューストア
- 情報をキーとバリュー（値）の形式で保存
- キーの値の重複は許されない
- 高速な読み書きが必要な設定データなど、小さなデータを保存・取得するのに適している
## ETCD をインストール
1. バイナリファイルをダウンロード
  ```
  curl -L https://github.com/etcd-io/etcd/releases/download/v3.4.20/etcd-v3.4.20-linux-arm64.tar.gz -o etcd-v3.4.20-linux-arm64.tar.gz
  ```
2. 展開
  ```
  tar xzvf etcd-v3.4.20-linux-arm64.tar.gz
  ```
3. ETCD を実行
  ```
  ./etcd
  ```
## 値の格納と取り出し
### 格納
```
./etcdctl set key1 value1
```
### 取り出し
```
./etcdctl get key1
```
## オプションを表示
```
./etcdctl
```
## Kubernetes における ETCD
- ノード、Pod、コンフィグ、シークレット、アカウント、ロール、バインディングなど、クラスタに関する情報を格納
- `kubectl get` コマンドを実行した時に表示される内容は、すべての ETCD の情報である
- ノートの追加、Pod やレプリカセットのデプロイなど、クラスタに加えたすべての変更を保持する
## Setup
### Manual
```
wget -q --https-only \
    "https://github.com/etcd-io/etcd/releases/download/v3.4.20/etcd-v3.4.20-linux-arm64.tar.gz"
```
### kubeadm
```
kubectl get pods -n kube-system
kubectl exec etcd-master -n kube-system etcdctl get / --prefix -key-only
```

## HA 環境
クラスタ内の複数のノードに分散して ETCD インスタンスが存在する状態

```
kubectl exec etcd-master -n kube-system -- sh -c "ETCDCTL_API=3 etcdctl get / --prefix --keys-only --limit=10 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt  --key /etc/kubernetes/pki/etcd/server.key" 
```

# ETCD - コマンド (オプション)

(オプション) ETCDCTLユーティリティに関する追加情報

ETCDCTL は ETCD と対話するために使用される CLI ツールです。

ETCDCTL は 2 つの API バージョン - Version 2 と Version 3 - を使って ETCD サーバと対話することができます。 デフォルトでは Version 2 を使用するように設定されています。それぞれのバージョンは異なるコマンドセットを持ちます。

例えば、ETCDCTL バージョン 2 は以下のコマンドをサポートしています。  
```
etcdctl backup
etcdctl cluster-health
etcdctl mk
etcdctl mkdir
etcdctl set
```

バージョン 3 ではコマンドは異なりますが
```
etcdctl snapshot save 
etcdctl endpoint health
etcdctl get
etcdctl put
```


正しいバージョンの API を設定するために、環境変数 ETCDCTL_API コマンドを設定します。
```
export ETCDCTL_API=3
```

APIバージョンが設定されていない場合、バージョン2が設定されているとみなされます。また、上記のバージョン3のコマンドは動作しません。APIバージョンがバージョン3に設定されている場合、上記のバージョン2のコマンドは動作しません。


これとは別に、ETCDCTLがETCD API Serverを認証できるように、証明書ファイルのパスを指定する必要があります。証明書ファイルはetcd-masterに以下のパスで用意されています。証明書については、このコースのセキュリティのセクションで詳しく説明します。ですから、これが複雑に見えても心配しないでください。
```
--cacert /etc/kubernetes/pki/etcd/ca.crt     
--cert /etc/kubernetes/pki/etcd/server.crt     
--key /etc/kubernetes/pki/etcd/server.key
```

そのため、前回の動画で紹介したコマンドを動作させるには、ETCDCTL APIのバージョンと証明書ファイルのパスを指定する必要があります。以下は最終形です。
```
kubectl exec etcd-master -n kube-system -- sh -c "ETCDCTL_API=3 etcdctl get / --prefix --keys-only --limit=10 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key" 
```

# kube-apiserver
- kubernetes コントロールプレーンのフロントエンド
- `kibectl` コマンドは kube-apiserver と会話する
- ETCD データストアと通信する唯一のコンポーネント
- kube-scheduler , kube-controller-manager , kubelet などの他のコンポーネントは kube-apiserver を使用してクラスタ内を更新する
## Pod を作成する手順
1. kube-apiserver が Pod オブジェクトを作成
2. kube-apiserver が ETCD サーバーの情報を更新
3. kube-apiserver がユーザーに Pod が作成されたことを通知
4. kube-scheduler が kube-apiserver を継続的に監視し、ノードに割り当てられていない Pod を検知
5. kube-scheduler は Pod を配置するのに適切なノードを特定し、それを kube-apiserver に伝える
6. kube-apiserver が ETCD の情報を更新
7. kube-apiserver が適切なノードの kubelet に通知
8. 通知を受けた kubelet がノード上に Pod を作成
9. kubelete がコンテナランタイムにアプリケーションイメージのデプロイを指示
10. デプロイの終了後、kubelet が kube-apiserver にステータスを通知
11. kube-apiserver が ETCD のデータを更新
## kube-apiserver をインストール
```
wget https://storage.googleapis.com/kubernetes-release/release/v1.13.0/bin/linux/amd64/kube-apiserver
```
## View api-server - kubeadm
```
kubectl get pods -n kube-system
```
## View api-server options - kubeadm
```
cat /etc/kubernetes/manifests/kube-apiserver.yaml
```
## View api-server options
```
cat /etc/systemd/system/kube-apiserver.service
ps -aux | grep kube-apiserver
```

# kube-controller-manager
- Kubernetes の様々なコントローラを管理する
- システムなの様々なコンポーネントの状態を継続的に監視し、システム全体を望ましい機能状態にするために働くプロセス
  - ノードコントローラ  
    - ノードの状態を監視し、アプリケーションの実効を維持するために必要なくアクションを取る役割を担っている
    - kube-apiserver 経由で 5 秒間隔でノードの状態を監視する
    - ノードからのハートビートを監視し、ハートビートがなくなってから 40 秒経過後到達不能とマークする
    - ノードが復活しない場合、ノード上で動作していた Pod を他のノードに割り当てる
  - レプリケーションコントローラ
    - レプリカセットの状態を監視し、レプリカセット内で常に指定された数の Pod を利用できるようにする役割を担っている
    - 動作中の Pod がダウンした場合、新たな Pod を作り出す
  - 上記以外に多数のコントローラが存在する
    - Deployment
    - Namespace
    - Endopoint
    - Job
    - Service-Account
    - PV-Binder
    - PV-Protection 等
  - コントローラはすべて Kubernetes-controller-manager と呼ばれる単一のプロセスにパッケージ化されている
## Installing kube-controller-manager
```
wget https://storage.googleapis.com/kubernete-release/release/v.13.0/bin/linux/amd64/kube-controller-manager
```
## View kube-controller-manager - kubeadm
```
kubectl get pods -n kube-system
```
## View kube-controller-manager options - kubeadm
```
cat /etc/kubernetes/manifests/kube-controll-ermanager.yaml
```
## View controller-manager options
```
cat /etc/systemd/system/kube-controller-manager.service
```
## View controller-manager options
```
ps -aux | grep kube-controller-manager
```

# kube-scheduler
- どの Pod をどのノードに配置するかを決定する（実際にノード上に Pod を配置するのは Kubelet の役割）
- kube-scheduler がノードを選択する手順
  1. Pod のリソース要件などから、選択肢から不適切なノードを除外する
  2. 各ノードに Pod を配置したあとに空くであろうリソース量を元に、各ノードをランク付けする
  3. ランクの高いノードを Pod の配置先に決定する
## Installing kube-scheduler
```
wget https://storage.googleapis.com/kubernetes-release/release/v1.13.0/bin/linux/amd64/kube-scheduler
```
## View kubernetes-scheduler options - kubeadm
```
cat /etc/kubernetes/manifests/kube-scheduler.yaml
```
## View kubernets-scheduler options
```
ps -aux | grep kube-scheduler
```

# kubelet
- kube-apiserver からの指示で kubernetes クラスタ上のノードに Pod を作成したり削除したりする
- 一定間隔でノードや Pod の状態を報告する
- Pod を作成する手順
  1. kube-apiserver が kubelet に Pod 作成の指示を出す
  2. 指示を受けた kubelet はコンテナランタイムエンジンに Pod イメージを引き出しインスタンスを実行するよう要求し、
  3. Pod とコンテナの状態の監視を続け、タイムリーに kube-apiserver に報告する
## Installing kubelet
```
wget https://storage.googleapis.com/kubernetes-release/release/v1.13.0/bin/linux/amd64/kubelet
```
## View kubelet options
```
ps -aux | grep kubelet
```

# kube-proxy
- kube-proxy は Kubernetes クラスタ内の各ノードで実行されるプロセス
- kube-proxy はサービスを探し、新しいサービスを見つけると、そのサービスへのトラフィックをバックエンドの Pod に転送するための適切なルートを作成する
- ルートを作成する方法の 1 つが iptables ルールを使用すること
## Installing kube-proxy
```
wget https://storage.googleapis.com/kubernetes-release/release/v1.13.0/bin/linux/amd64/kube-proxy
```
## View kube-proxy - kubeadm
```
kubectl get pods -n kube-system
kubectl get deamonset -n kube-system
```

#  Recap - PODs